(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{391:function(e,t,s){"use strict";s.r(t);var a=s(45),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h3",{attrs:{id:"account-address"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#account-address"}},[e._v("#")]),e._v(" Account Address")]),e._v(" "),s("p",[e._v("SS58 is a simple address format designed for Substrate based chains. There's no problem with using other address formats for a chain, but this serves as a robust default. It is heavily based on Bitcoin's Base-58-check format with a few alterations.")]),e._v(" "),s("p",[e._v("The basic idea is a base-58 encoded value that can identify a specific account on the Substrate chain. Different chains have different means of identifying accounts. SS58 is designed to be extensible for this reason.")]),e._v(" "),s("p",[e._v("The living specification for the SS-58 address format can be found on the Substrate GitHub wiki:")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/paritytech/substrate/wiki/External-Address-Format-(SS58)",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/paritytech/substrate/wiki/External-Address-Format-(SS58)"),s("OutboundLink")],1)]),e._v(" "),s("h3",{attrs:{id:"account-keys"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#account-keys"}},[e._v("#")]),e._v(" Account Keys")]),e._v(" "),s("p",[e._v("GEEK uses multiple sets of public/private key pairs to represent participants of the network.")]),e._v(" "),s("p",[e._v("Blockchain systems have participants in varying roles, for example from validators to normal users.")]),e._v(" "),s("p",[e._v("As an example, the GEEK node uses a Nominated Proof-of-Stake (NPoS) algorithm to select validators. Validators and nominators may hold significant amounts of funds, so GEEK's Staking module introduces account abstractions that help keep funds as secure as possible.")]),e._v(" "),s("p",[e._v("These abstractions are:")]),e._v(" "),s("h3",{attrs:{id:"accounts"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#accounts"}},[e._v("#")]),e._v(" Accounts")]),e._v(" "),s("p",[s("code",[e._v("Stash Key:")]),e._v(" The Stash account is meant to hold large amounts of funds. Its private key should be as secure as possible in a cold wallet.")]),e._v(" "),s("p",[s("code",[e._v("Controller Key:")]),e._v(" The Controller account signals choices on behalf of the Stash account, like payout preferences, but should only hold a minimal amount of funds to pay transaction fees. Its private key should be secure as it can affect validator settings, but will be used somewhat regularly for validator maintenance.")]),e._v(" "),s("p",[s("code",[e._v("Session Keys:")]),e._v(' Session keys are "hot" keys kept in the validator client and used for signing certain validator operations. They should never hold funds.')]),e._v(" "),s("h3",{attrs:{id:"account-keys-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#account-keys-2"}},[e._v("#")]),e._v(" Account Keys")]),e._v(" "),s("p",[e._v('A key pair can represent an account and control funds, like normal accounts that you would expect from other blockchains. In the context of GEEK\'s Balances module, these accounts must have a minimum amount (an "existential deposit") to exist in storage.')]),e._v(" "),s("p",[e._v("Account keys are defined generically and made concrete in the runtime.")]),e._v(" "),s("p",[e._v("To continue with our example of Stash and Controller accounts, the keys to these accounts are distinguished by their intended use, not by any underlying cryptographic difference. When creating Stash or Controller keys, all cryptography supported for normal account keys are also supported.")]),e._v(" "),s("h3",{attrs:{id:"stash-keys"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stash-keys"}},[e._v("#")]),e._v(" Stash Keys")]),e._v(" "),s("p",[e._v('The Stash keys are the public/private key pair that defines a Stash account. This account is like a "savings account" in that you should not make frequent transactions from it. Therefore, its private key should be treated with the utmost security, for example protected in a safe or layers of hardware security.')]),e._v(" "),s("p",[e._v("Since the Stash key is kept offline, it designates a Controller account to make non-spending decisions with the weight of the Stash account's funds. It can also designate a Proxy account to vote in governance on its behalf.")]),e._v(" "),s("h3",{attrs:{id:"controller-keys"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#controller-keys"}},[e._v("#")]),e._v(" Controller Keys")]),e._v(" "),s("p",[e._v("The Controller keys are the public/private key pair that defines a Controller account. In the context of Substrate's NPoS model, the Controller key will signal one's intent to validate or nominate.")]),e._v(" "),s("p",[e._v("The Controller key is used to set preferences like the rewards destination and, in the case of validators, to set their Session keys. The Controller account only needs to pay transaction fees, so it only needs a minimal amount of funds.")]),e._v(" "),s("p",[e._v("The Controller key can never be used to spend funds from its Stash account. However, actions taken by the Controller can result in slashing, so it should still be well secured.")]),e._v(" "),s("h3",{attrs:{id:"session-keys"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#session-keys"}},[e._v("#")]),e._v(" Session Keys")]),e._v(" "),s("p",[e._v('Session keys are "hot keys" that are used by validators to sign consensus-related messages. They are not meant to be used as account keys that control funds and should only be used for their intended purpose. They can be changed regularly; your Controller only needs to create a certificate by signing a session public key and broadcast this certificate via an extrinsic. Session keys are also defined generically and made concrete in the runtime.')]),e._v(" "),s("p",[e._v("To create a Session key, validator operators must attest that a key acts on behalf of their Stash account (stake) and nominators. To do so, they create a certificate by signing the key with their Controller key. Then, they inform the chain that this key represents their Controller key by publishing the Session certificate in a transaction on the chain.")]),e._v(" "),s("p",[e._v("GEEK provides the Session module, which allows validators to manage their session keys.")]),e._v(" "),s("h3",{attrs:{id:"strongly-typed-wrappers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#strongly-typed-wrappers"}},[e._v("#")]),e._v(" Strongly Typed Wrappers")]),e._v(" "),s("p",[e._v('You can declare any number of Session keys. For example, the default GEEK node uses four for BABE, GRANDPA, "I\'m Online" and "Authority Discovery". Other chains could have more or fewer depending on what operations the chain expects its validators to perform.')]),e._v(" "),s("p",[e._v("These different Session keys could use the same cryptography, but serve very different purposes throughout your runtime logic. To prevent the wrong key being used for the wrong operation, strong Rust types wrap these keys, keeping them incompatible with one another and ensuring they are only used for their intended purpose.")]),e._v(" "),s("h3",{attrs:{id:"generation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generation"}},[e._v("#")]),e._v(" Generation")]),e._v(" "),s("p",[e._v("If a Session key is compromised, attackers could commit slashable behavior. Session keys should be changed regularly (e.g. every session) via the "),s("code",[e._v("rotate_keys")]),e._v(" RPC for increased security.")])])}),[],!1,null,null,null);t.default=o.exports}}]);