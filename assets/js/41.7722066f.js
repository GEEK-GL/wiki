(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{422:function(e,t,a){"use strict";a.r(t);var s=a(45),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"secure-validator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#secure-validator"}},[e._v("#")]),e._v(" Secure Validator")]),e._v(" "),a("p",[e._v("Validators in a Proof of Stake network are responsible for keeping the network in consensus and verifying state transitions. As the number of validators is limited, validators in the set have the responsibility to be online and faithfully execute their tasks.")]),e._v(" "),a("p",[e._v("This primarily means that validators:")]),e._v(" "),a("ul",[a("li",[e._v("Must have infrastructure that protects the validator's signing keys so that an attacker cannot take control and commit slashable behavior.")]),e._v(" "),a("li",[e._v("Must be high availability.")])]),e._v(" "),a("h3",{attrs:{id:"high-availability"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#high-availability"}},[e._v("#")]),e._v(" High Availability")]),e._v(" "),a("p",[e._v("High availability set-ups that involve redundant validator nodes may seem attractive at first. However, they can be "),a("strong",[e._v("very dangerous")]),e._v(" if they are not set up perfectly. The reason for this is that the session keys used by a validator should always be isolated to just a single node. Replicating session keys across multiple nodes could lead to equivocation slashes, or soon to parachain validity slashes which can make you lose "),a("strong",[e._v("100% of your staked funds")]),e._v(".")]),e._v(" "),a("p",[e._v("The good news is that 100% uptime of your validator is not really needed, as it has some buffer within eras in order to go offline for a little while and upgrade. For this reason, we advise that you only attempt a high availability set-up if you're confident you know exactly what you're doing. Many expert validators have made mistakes in the past due to the handling of session keys.")]),e._v(" "),a("p",[e._v("Remember, even if your validator goes offline for some time, the offline slash is much more forgiving than the equivocation or parachain validity slashing.")]),e._v(" "),a("h3",{attrs:{id:"key-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#key-management"}},[e._v("#")]),e._v(" Key Management")]),e._v(" "),a("p",[e._v("See the "),a("a",{attrs:{href:"/account"}},[e._v("Keys guide")]),e._v(" for more information on keys. The keys that are of primary concern for validator infrastructure are the Session keys. These keys sign messages related to consensus and parachains. Although Session keys are not account keys and therefore cannot transfer funds, an attacker could use them to commit slashable behavior.")]),e._v(" "),a("p",[e._v("Session keys are generated inside the node via RPC call. See the Kusama guide for instructions on setting Session keys. These should be generated and kept within your client. When you generate new Session keys, you must submit an extrinsic (a Session certificate) from your Controller key telling the chain your new Session keys.")]),e._v(" "),a("div",{staticClass:"warning custom-block"},[a("p",[a("strong",[e._v("NOTE:")]),e._v(" Session keys can also be generated outside the client and inserted into the client's keystore via RPC. For most users, we recommend using the key generation functionality within the client.\n    ")])]),e._v(" "),a("h3",{attrs:{id:"signing-outside-the-client"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#signing-outside-the-client"}},[e._v("#")]),e._v(" Signing Outside the Client")]),e._v(" "),a("p",[e._v("In the future, GEEK will support signing payloads outside the client so that keys can be stored on another device, e.g. a hardware security module (HSM) or secure enclave. For the time being, however, Session key signatures are performed within the client.")]),e._v(" "),a("div",{staticClass:"warning custom-block"},[a("p",[a("strong",[e._v("NOTE:")]),e._v(" HSMs are not a panacea. They do not incorporate any logic and will just sign and return whatever payload they receive. Therefore, an attacker who gains access to your validator node could still commit slashable behavior.\n    ")])]),e._v(" "),a("p",[e._v("An example of highly available, secure setup would be a layer of sentry nodes in front of multiple validators connected to a single signing machine. This machine could implement signing logic to avoid equivocation, even if an attacker gained access to a validator node.")]),e._v(" "),a("h3",{attrs:{id:"linux-best-practices"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linux-best-practices"}},[e._v("#")]),e._v(" Linux Best Practices")]),e._v(" "),a("ul",[a("li",[e._v("Never use the root user.")]),e._v(" "),a("li",[e._v("Always update the security patches for your OS.")]),e._v(" "),a("li",[e._v("Enable and set up a firewall.")]),e._v(" "),a("li",[e._v("Never allow password-based SSH, only use key-based access.")]),e._v(" "),a("li",[e._v("Disable non-essential SSH subsystems (banner, motd, scp, X11 forwarding) and harden your SSH configuration ("),a("a",{attrs:{href:"https://stribika.github.io/2015/01/04/secure-secure-shell.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("reasonable guide to begin with"),a("OutboundLink")],1),e._v(").")]),e._v(" "),a("li",[e._v("Back up your storage regularly.")])]),e._v(" "),a("h3",{attrs:{id:"conclusions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conclusions"}},[e._v("#")]),e._v(" Conclusions")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("At the moment, GEEK can't interact with HSM/SGX, so we need to provide the signing key seeds to the validator machine. This key is kept in memory for signing operations and persisted to disk (encrypted with a password).")])]),e._v(" "),a("li",[a("p",[e._v("Given that HA setups would always be at risk of double-signing and there's currently no built-in mechanism to prevent it, we propose having a single instance of the validator to avoid slashing. Slashing penalties for being offline are much less than those for equivocation.")])])]),e._v(" "),a("h3",{attrs:{id:"validators"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#validators"}},[e._v("#")]),e._v(" Validators")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Validators should only run the GEEK binary, and they should not listen on any port other than the configured p2p port.")])]),e._v(" "),a("li",[a("p",[e._v("Validators should run on bare-metal machines, as opposed to VMs. This will prevent some of the availability issues with cloud providers, along with potential attacks from other VMs on the same hardware. The provisioning of the validator machine should be automated and defined in code. This code should be kept in private version control, reviewed, audited, and tested.")])]),e._v(" "),a("li",[a("p",[e._v("Session keys should be generated and provided in a secure way.")])]),e._v(" "),a("li",[a("p",[e._v("GEEK should be started at boot and restarted if stopped for any reason (supervisor process).")])]),e._v(" "),a("li",[a("p",[e._v("GEEK should run as non-root user.")])])]),e._v(" "),a("h3",{attrs:{id:"monitoring"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#monitoring"}},[e._v("#")]),e._v(" Monitoring")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("There should be an on-call rotation for managing the alerts.")])]),e._v(" "),a("li",[a("p",[e._v("There should be a clear protocol with actions to perform for each level of each alert and an escalation policy.")])])])])}),[],!1,null,null,null);t.default=i.exports}}]);